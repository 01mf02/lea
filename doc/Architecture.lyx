#LyX 2.0 created this file. For more info see http://www.lyx.org/
\lyxformat 413
\begin_document
\begin_header
\textclass article
\use_default_options true
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding auto
\fontencoding global
\font_roman default
\font_sans default
\font_typewriter default
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100

\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize default
\use_hyperref false
\papersize default
\use_geometry false
\use_amsmath 1
\use_esint 1
\use_mhchem 1
\use_mathdots 1
\cite_engine basic
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\use_refstyle 1
\index Index
\shortcut idx
\color #008000
\end_index
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Title
Architecture of the Léa compiler
\end_layout

\begin_layout Author
Michael Färber
\end_layout

\begin_layout Section
Roadmap
\end_layout

\begin_layout Standard
I propose to implement little bits of language functionality one after another.
 As a start, we should be able to make an AST for the following source code:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

procedure main()
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

	writeln("Hello world!");
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset

Then, we might add constants as such:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

MEANING = 42;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

procedure main()
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

	writeln("Hello world!");
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset

After this, conditionals might follow:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

MEANING = 42;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

procedure main()
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

	if (MEANING = 42)
\end_layout

\begin_layout Plain Layout

	{
\end_layout

\begin_layout Plain Layout

		writeln("Hello world!");
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset

Then variable declarations/assignments:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

procedure main()
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

	meaning : int;
\end_layout

\begin_layout Plain Layout

	meaning := 42;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	if (meaning = 42)
\end_layout

\begin_layout Plain Layout

	{
\end_layout

\begin_layout Plain Layout

		writeln("Hello world!");
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset

Then function calling:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

procedure print_greetings()
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

	writeln("Hello from print_greetings()!");
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

procedure main()
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

	writeln("Hello world!");
\end_layout

\begin_layout Plain Layout

	print_greetings();
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset

Then function returns:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

function calculate_meaning() : int
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

	return 42;
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

procedure main()
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

	meaning : int;
\end_layout

\begin_layout Plain Layout

	meaning := calculate_meaning();
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	if (meaning = 42)
\end_layout

\begin_layout Plain Layout

	{
\end_layout

\begin_layout Plain Layout

		writeln("Hello world!");
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset

And so on ...
\end_layout

\begin_layout Section
Syntax
\end_layout

\begin_layout Standard
The syntax part is concerned with Cup/JFlex.
 The JFlex part is the interface to the semantics part.
 It has to:
\end_layout

\begin_layout Itemize
add type declarations to the type table
\end_layout

\begin_layout Itemize
add function declarations/definitions and constant definitions to the root
 environment
\end_layout

\begin_layout Itemize
construct new environments in case of nesting
\end_layout

\begin_layout Standard
For these tasks, the JFlex part needs access to following classes:
\end_layout

\begin_layout Itemize
SyntaxTree
\end_layout

\begin_layout Itemize
Environment
\end_layout

\begin_layout Itemize
Type
\end_layout

\begin_layout Itemize
Value
\end_layout

\begin_layout Standard
Furthermore, it needs access to the type table.
\end_layout

\begin_layout Subsection
Grammar
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

top_level = def | func_def | top_level top_level
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

def = literal = def_right;
\end_layout

\begin_layout Plain Layout

def_right = type | const
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

type = int | string | bool | char | struct { decls } | list of type | literal
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

func_def = function literal(input_params) : output_param { instr_block }
\end_layout

\begin_layout Plain Layout

input_params = decl | input_params, decls
\end_layout

\begin_layout Plain Layout

output_param = type | literal
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

instr_block = instr; | instr_block instr;
\end_layout

\begin_layout Plain Layout

instr = ret_instr | func_call_instr | decl | ass_instr | for_instr | ...
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

ret_instr = return expression
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

func_call_instr = literal(exprs)
\end_layout

\begin_layout Plain Layout

exprs = expr | exprs, expr
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

decl = literal : type
\end_layout

\begin_layout Plain Layout

decls = decl | decls, decl
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

ass_instr = assignable := expression
\end_layout

\begin_layout Plain Layout

assignable = literal | assignable[expr] | assignable.literal
\end_layout

\end_inset


\end_layout

\begin_layout Section
Semantics
\end_layout

\begin_layout Standard
This part is concerned with the checking of the abstract syntax tree (AST)
 and the generation of the intermediate code.
 To enable program execution at an early point in development (before the
 generation of target code), each AST object needs to be able to evaluate
 on a given environment.
 This way, we can simulate program execution in the compiler in an easy
 fashion to check if our programs work correctly.
\end_layout

\begin_layout Subsection
Abstract syntax tree
\end_layout

\begin_layout Standard
JFlex constructs an AST for each function in a Léa source file and adds
 it to the function table.
 During the construction of the AST, the AST has to check if its instructions
 are valid, i.e.
 type consistent.
\end_layout

\begin_layout Standard
We use several classes derived from a basic SyntaxTree class to represent
 the different instructions that may appear in a Léa program.
 For example, we may have the following classes:
\end_layout

\begin_layout Itemize
Assignment.java
\end_layout

\begin_layout Itemize
Atom.java: stands for all elementary objects, such as variables, constants,
 enums.
\end_layout

\begin_layout Itemize
FunctionCall.java
\end_layout

\begin_layout Itemize
Return.java: return instruction.
\end_layout

\begin_layout Itemize
Writeln.java: implements the writeln() function.
\end_layout

\begin_layout Itemize
\begin_inset Formula $\dots$
\end_inset


\end_layout

\begin_layout Standard
The execution function of each of these classes may return an Object instance
 (in case of expressions) or null (in case of instructions).
\end_layout

\begin_layout Standard
We should also provide a function to create a graph from an AST.
\end_layout

\begin_layout Subsection
Environment
\end_layout

\begin_layout Standard
An environment stores tuples (object_name, object_type, object_value).
 Internally, this might be implemented as a Map<String, TypeValue>, where
 TypeValue is an auxiliary data type storing a type (Type) and a value (Object).
 Note that functions are also stored in the environment --- they have a
 special type FunctionType, and their object_value is an AST (or null, if
 the function has only been declared, but not defined).
 The JFlex part puts constants into the environment as well, but only in
 the root environment --- objects in the root environment therefore cannot
 be modified.
 (During semantic verification, this can be checked by looking at the value
 of objects which are about to be modified.
 Because only constants have a non-null value during verification, this
 is a safe way to check if we are dealing with constants or not.
 That means, if we encounter an assignment of a data object which is non-null,
 we trigger an error.
 The same way, we can detect if we are about to define a function several
 times in the source code.)
\end_layout

\begin_layout Standard
Each AST has a reference to an environment, by which the AST may access
 information about objects in its environment.
\end_layout

\begin_layout Subsection
Type
\end_layout

\begin_layout Standard
The Type class is the superclass of several derived classes, such as:
\end_layout

\begin_layout Itemize
FunctionType
\end_layout

\begin_layout Itemize
StructType
\end_layout

\begin_layout Itemize
IntType
\end_layout

\begin_layout Itemize
FloatType
\end_layout

\begin_layout Itemize
ListType
\end_layout

\begin_layout Itemize
\begin_inset Formula $\dots$
\end_inset


\end_layout

\begin_layout Standard
Each of these classes has to be able to check equality with another type.
 Furthermore, for the source code execution, each class also has to be able
 to construct a default value.
 This is important for example in the case of a StructType:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

foo: struct { first: int, second: int }
\end_layout

\begin_layout Plain Layout

foo.first := 2;
\end_layout

\end_inset

In this example, the variable 
\begin_inset Quotes eld
\end_inset

foo
\begin_inset Quotes erd
\end_inset

 has to be initialised in order to be able to modify it later.
 This is achieved by constructing a default value for the struct type at
 the declaration of 
\begin_inset Quotes eld
\end_inset

foo
\begin_inset Quotes erd
\end_inset

.
\end_layout

\begin_layout Subsection
Value
\end_layout

\begin_layout Standard
For more complex datatypes, such as tuples or lists, we need special data
 structures to store their values, such as:
\end_layout

\begin_layout Itemize
FunctionValue: does not exist as own type, use SyntaxTree class directly.
\end_layout

\begin_layout Itemize
StructValue: saves tuples of (data_name, data_type, data_value).
 May be implemented as Map<String, TypeValue>.
\end_layout

\begin_layout Itemize
IntValue: does not exist as own type, use Integer class directly.
\end_layout

\begin_layout Itemize
\begin_inset Formula $\dots$
\end_inset


\end_layout

\begin_layout Standard
However, Value as an own class doesn't exist, because the only function
 it could fulfill would be to provide an instance of Object, which we can
 achieve by using Object directly.
\end_layout

\begin_layout Subsection
Type table
\end_layout

\begin_layout Standard
The type table stores type definitions, such as:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

int_list = struct {
\end_layout

\begin_layout Plain Layout

	next: list
\end_layout

\begin_layout Plain Layout

	elem: int
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

color = enum (RED, GREEN, BLUE)
\end_layout

\end_inset

For this, we have to store tuples (type_name, type) in a table, which is
 the type table.
 This may be realised as Map<String, Type>.
\end_layout

\end_body
\end_document
