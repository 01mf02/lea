package lea;
 
import java_cup.runtime.*;
import java.io.*;
import java.lang.*;
import java.util.*;
import lea.types.*;
import lea.constants.*;
import lea.syntax.*;

    
terminal SEMIC,PROCEDURE, FUNCTION, LBRACKET, RBRACKET, LPAR, RPAR ,COLON, LBRACE, RBRACE, INT, FLOAT,LIST,OF,STRUCT, STRING, CHAR, BOOL,COMMA;
terminal IF, ELSE, CASE,IN;
terminal WHILE, REPEAT,FOR;
terminal AFF, SLOT, TO;
terminal RETURN;
terminal AND, OR, LT, GT, LE, GE, EQ, DIFF;
terminal PLUS, MINUS, MINUS_U, MULT, DIV, MODULO;

terminal String IDENTIFIER, INTEGER, FLOATEXP, STRINGEXP, CHAREXP, TRUEEXP, FALSEEXP;

non terminal axiom,constDecl,funct,procedure,struct,structDecls, structDecl,erreur;
non terminal Instruction decl;
non terminal Type type;
non terminal LinkedList<ArgumentInfo> functDecls;
non terminal ArgumentInfo functDecl;
non terminal SyntaxTree block;
non terminal Instruction instrs, instr;
non terminal Expression expr;
non terminal String BOOLEXP;
non terminal Expression variable;

precedence left COMMA;
precedence right ELSE;
precedence left AND;
precedence left OR;
precedence left LT, GT, LE, GE, EQ, DIFF;
precedence left PLUS, MINUS;
precedence left MULT, DIV, MODULO;
precedence left MINUS_U;
precedence left SLOT;

start with axiom;

axiom ::= 
		funct
		| funct axiom
		| procedure
		| procedure axiom
		| constDecl axiom
		| constDecl	
		| struct axiom
		| struct
		| erreur axiom
		| erreur
		;
		
		
erreur ::= 
		error SEMIC
		{:
			System.out.println("\n Erreur dans un terminal : ; \n");
		:}
		| error RBRACE
		{:
			System.out.println("\n Erreur dans un terminal : } \n");
		:}
		| error LPAR
		{:
			System.out.println("\n Erreur dans un terminal : ) \n");
		:}
		;		
		
		
type ::=
		INT {: RESULT = new IntType();  :}
		| FLOAT {: RESULT = new FloatType();  :}
		| type:t1 COMMA type:t2 {: RESULT = new TupleType(t1, t2); :} 
		| CHAR   {: RESULT = new CharType(); :}
		| STRING  {: RESULT = new StringType(); :}
		| BOOL {: RESULT = new BoolType(); :}
		| LIST OF type:t {: RESULT = new ListType(t); :}
		| IDENTIFIER:t 
		{:
			/*if(Main.)
			{*/
				RESULT = Main.typeTable.get(t);
			/*}
			else*/
				//error
			
		:}
		/*| LIST OF IDENTIFIER:t 
		{: //TODO : vérifier pour les identifier struct
		RESULT =  RESULT = new ListType(t); 
		:}*/
		;
		
		
constDecl ::= 
		IDENTIFIER:id EQ INTEGER:i SEMIC
		{:
		  	Main.constTable.put(id, new IntConstant(i));
		  	System.out.println("\nCONST : " + Main.constTable.toString() + "\n");
		:}
		;
		
		
block ::=
		LBRACE
		{:
		    System.out.println("BLOCK");
		    SyntaxTree sTree = new SyntaxTree(null, null);
		    
		    Main.currentNode = sTree;
		:}  instrs:i RBRACE {: RESULT = i; :}
		;


decl ::=  IDENTIFIER:id COLON type:t SEMIC
		{:
			if(Main.currentNode != null)
			{
				Main.currentNode.getEnvironment().put(id, new VariableInfo(t, false));
				System.out.println("ENV : " + Main.currentNode.getEnvironment().toString());
			}
			else
				System.out.println("D�CLARATION VARIABLE GLOBALE INTERDITE!! FAUT G�RER CA ICI!");
				
			RESULT = new Assignment(new VariableLeaf(id, t), null);
		:}
		| IDENTIFIER:id COLON type:t AFF expr:e SEMIC
		{:
			if(Main.currentNode != null)
			{
				Main.currentNode.getEnvironment().put(id, new VariableInfo(t, true));
				
				System.out.println("ENV : " + Main.currentNode.getEnvironment().toString());
				RESULT = new Assignment(new VariableLeaf(id, t), e); 
			}
			else
				System.out.println("D�CLARATION VARIABLE GLOBALE INTERDITE!! FAUT G�RER CA ICI!");
		:} 
		;


structDecls ::= structDecls structDecl | structDecl | erreur;


structDecl ::=  IDENTIFIER:id COLON type:t SEMIC
		{:
			if(Main.currentNode != null)
			{
				Main.currentNode.getEnvironment().put(id, new VariableInfo(t, false));
				System.out.println("ENV : " + Main.currentNode.getEnvironment().toString());
			}
			else
				System.out.println("D�CLARATION VARIABLE GLOBALE INTERDITE!! FAUT G�RER CA ICI!");
				
			RESULT = new Assignment(new VariableLeaf(id, t), null);
		:};


struct ::= IDENTIFIER:id EQ STRUCT 
		 {:
			System.out.println("STRUCT");
		    SyntaxTree sTree = new SyntaxTree(null, null);
		    
		    Main.currentNode = sTree;
		    //Ou mettre le fich?
		    Main.typeTable.put(id,new StructType(id));
		:}LBRACE structDecls RBRACE 
		{:
			StructType st = (StructType)Main.typeTable.get(id);
			st.setEnvironment(Main.currentNode.getEnvironment());
		:}
		;


BOOLEXP ::=
		TRUEEXP:t {:RESULT = t; :}
		|FALSEEXP:t {:RESULT = t; :};


funct ::= 
		FUNCTION IDENTIFIER:id LPAR functDecls:f RPAR COLON type:t block:b
		{:
			FunctionInfo fctInfo = new FunctionInfo(f, t, b);
			Main.fctTable.put(id, fctInfo);
			
			System.out.println("\n\nFCT : " + Main.fctTable.toString() + "\n");
		:}
		;
		
		
procedure ::= 
		PROCEDURE IDENTIFIER:id LPAR functDecls:f RPAR block:b
		{:
			FunctionInfo fctInfo = new FunctionInfo(f, null, b);
			Main.fctTable.put(id, fctInfo);
			
			System.out.println("\n\nFCT : " + Main.fctTable.toString() + "\n");
		:}
		;

		
functDecls ::=
		functDecls:l COMMA functDecl:f
		{:
			l.add(f);
			RESULT = l;
		:}
		| functDecl:f 
		{: 
			LinkedList<ArgumentInfo> l = new LinkedList<ArgumentInfo>();
			l.add(f);
			RESULT = l;  
		:}
		;


functDecl ::=  IDENTIFIER:id COLON type:t {: RESULT = new ArgumentInfo(id, t); :} ;
		
		
instr ::= 
		IF LPAR expr:e RPAR block:i1 ELSE block:i2  {: RESULT = new Condition(e, new ElseCondition(i1, i2)); :}
		| IF LPAR expr:e RPAR block:i   {: RESULT = new Condition(e, i); :}
		| REPEAT TO CASE
		| FOR IDENTIFIER:i IN LBRACKET TO RBRACKET LBRACE block:b RBRACE
		| variable:v AFF expr:e SEMIC 
		{: 
			//TODO MHB : TYPE CHECKING HERE 
			//if(v instanceof VariableLeaf)
				RESULT = new Assignment(v, e); 
			//ELSE ERROR
		:}
		| REPEAT block:b WHILE LPAR expr:e RPAR 
		{: RESULT = new Loop(e, b); :}
		| decl:d {: RESULT = d;	:}
		| erreur
		;


instrs ::= 
		instrs:i1 instr:i2   {: RESULT = new Succ(i1, i2); :}
		| instr:i  {: RESULT = i; :}
		;


expr ::=
		expr:e1 AND expr:e2 {: RESULT = new BoolExp(e1, e2, EnumTagExp.AND); :} 
		|expr:e1 OR expr:e2 {: RESULT = new BoolExp(e1, e2, EnumTagExp.OR); :} 
		|expr:e1 LT expr:e2 {: RESULT = new BoolExp(e1, e2, EnumTagExp.LT); :} 
		|expr:e1 GT expr:e2 {: RESULT = new BoolExp(e1, e2, EnumTagExp.GT); :} 
		|expr:e1 LE expr:e2 {: RESULT = new BoolExp(e1, e2, EnumTagExp.LE); :} 
		|expr:e1 GE expr:e2 {: RESULT = new BoolExp(e1, e2, EnumTagExp.GE); :} 
		|expr:e1 EQ expr:e2 {: RESULT = new BoolExp(e1, e2, EnumTagExp.EQ); :} 
		|expr:e1 DIFF expr:e2 {: RESULT = new NumberExp(e1, e2, EnumTagExp.DIFF); :} 
		|expr:e1 PLUS expr:e2 {: RESULT = new NumberExp(e1, e2, EnumTagExp.PLUS); :} 
		|expr:e1 MINUS expr:e2 {: RESULT = new NumberExp(e1, e2, EnumTagExp.MINUS); :} 
		|MINUS expr:e {: RESULT = new NumberExp(e, null, EnumTagExp.MINUS_U); :} %prec MINUS_U 
		|expr:e1 MULT expr:e2 {: RESULT = new NumberExp(e1, e2, EnumTagExp.MULT); :} 
		|expr:e1 DIV expr:e2 {: RESULT = new NumberExp(e1, e2, EnumTagExp.DIV); :} 
		|expr:e1 MODULO expr:e2 {: RESULT = new NumberExp(e1, e2, EnumTagExp.MOD); :} 
		|LPAR expr:e RPAR {: RESULT = e; :}
		|RETURN expr:e {: RESULT = new ReturnNode(e); :}
		|INTEGER:it {: 
			RESULT = new ConstantLeaf(new IntConstant(it)); 
			:}
		|FLOATEXP:d {: 
			RESULT = new ConstantLeaf(new FloatConstant(d)); 
			:}
		|STRINGEXP:st {: 
			RESULT = new ConstantLeaf(new StringConstant(st));  
			:}
		|CHAREXP:c {: 
			RESULT = new ConstantLeaf(new CharConstant(c));  
			:}
		|variable:v {: RESULT = v; :}
		|BOOLEXP:b {: 
			RESULT = new ConstantLeaf(new BoolConstant(b)); 
			:}
		/*| expr:e1 COMMA expr:e2 {: RESULT = new ListNode(new Succ(e1, e2)); :}*/
		;
	
	
variable ::=
    	IDENTIFIER:id 
    	{:    		
    		//TODO MHB : RAISE ERROR IF t & c == null
    		Constant c = Main.constTable.get(id);
    		
    		if(c == null)
    		{
    			VariableInfo vi = Main.currentNode.getEnvironment().get(id);
    			
				if(vi != null)
				{
					Type t = vi.getType();
					RESULT = new VariableLeaf(id, t);
				}
				//ERROR IF t == NULL
    		}
    		else
    			RESULT = new ConstantLeaf(c);
    	:}
    	| variable:v SLOT 
    	{:
    		if(v.getType() instanceof StructType)
    		{     		
    			StructType st = (StructType)v.getType();    			 
				Main.currentNode.setEnvironment(st.getEnvironment()); 
			}
		:} 
		variable:v1 
		{:    	
    		if(v.getType() instanceof StructType)
    		{
	    		StructType st = (StructType)v.getType();
				VariableInfo vi = st.getEnvironment().get(((VariableLeaf)v1).getName());
				System.out.println("Variable dans la structure : " + vi.toString());

				RESULT = new StructAccessor(v, v1);
    		}
    	:}
    	| IDENTIFIER:id LPAR expr:e RPAR
    	{:
    		if(Main.fctTable.containsKey(id))
    		{
    			//FunctionCall extends expr?
    		}
    		//else error
    	:}
    	| variable:v LBRACKET expr:e RBRACKET
    	{:
    		boolean isOk = false;
    		
    		if(v instanceof VariableLeaf)
    		{
    			if(v.getType() instanceof ListType)
    			{
		    		if(e.getType().equals(new IntType()))
	    			{
	    				RESULT = new ListAccessor(v, e);
	    				isOk = true;
	    			}
	    		}
    		}
    			//error dans tous les autres cas
    		if(!isOk)
    		{
    		
    		}
    	:}
		;
	
    
  /**Liste de TODO
  List doit fonctionner
  slot doit fonctionner
  on doit importer tout les variables
  tuples
  retour fonction
  fonction sans decls
  */
  
  
  
  
  
  
  
  
  
  
  
  
   
    