package lea;
 
import java_cup.runtime.*;
import java.io.*;
import java.lang.*;
import java.util.*;
import lea.types.*;
import lea.constants.*;
import lea.syntax.*;

parser code  {: 
 public void report_fatal_error(String message, Object info) 
  {
  	report_error( message,  info);
  }
  
  public void report_error(String message, Object info) 
  {
  	java_cup.runtime.Symbol symb = (java_cup.runtime.Symbol)info;
  	System.out.println("Ligne : " + symb.left + " Colonne : " + symb.right + "   : " + message);
  }
:};

/*terminal IF, THEN, ELSE, WHILE, DO,
    OF, 
    LPAR, RPAR, LBRACE, RBRACE, LBRACKET, RBRACKET,
    SEMIC, COLON,
    AFF, AND, OR, LT, GT, LE, GE, EQ, DIFF, PLUS, MINUS, MINUS_U, MULT, DIV,
    INT, FLOAT, STRING, CHAR, BOOL,
    FUNCTION,LIST, TRUE, FALSE,
    COMMA, STRUCT,SLOT,MODULO,TO,REPEAT,BOOL,CASE;*/
    
terminal EQ, SEMIC,FUNCTION, LPAR,RPAR ,COLON, LBRACE, RBRACE,INT, FLOAT, STRING, CHAR, BOOL,COMMA;

terminal String IDENTIFIER, INTEGER;

non terminal axiom,constDecl,funct,decls,decl;
non terminal Type type;
non terminal LinkedList<ArgumentInfo> functDecls;
non terminal ArgumentInfo functDecl;
non terminal SyntaxTree block;

start with axiom;

axiom ::= 
		funct
		|constDecl axiom
		|funct axiom
		|constDecl	
		;
		
type ::=
	INT {: RESULT = new IntType();  :}
	| FLOAT {: RESULT = new FloatType();  :}
	| CHAR   {: RESULT = new CharType(); :}
	| STRING  {: RESULT = new StringType(); :}
	| BOOL {: RESULT = new BoolType(); :}
	;
		
		
constDecl ::= 
		IDENTIFIER:id EQ INTEGER:i SEMIC
		{:
		  	Main.constTable.put(id, new IntConstant(i));
		  	System.out.println("\nCONST : " + Main.constTable.toString() + "\n");
		:}
		;
	
funct ::= 
		FUNCTION IDENTIFIER:id LPAR functDecls:f RPAR COLON type:t block:b
		{:
			FunctionInfo fctInfo = new FunctionInfo(f, t, b);
			Main.fctTable.put(id, fctInfo);
			
			System.out.println("\n\nFCT : " + Main.fctTable.toString() + "\n");
		:};
		
block ::=
	LBRACE 
	{:
	    System.out.println("BLOCK ");
	    SyntaxTree sTree = new SyntaxTree(null, null);
	    
	    Main.currentNode = sTree;
	    RESULT = sTree;
	:} decls RBRACE 
	;

decls ::=
	decls decl
	| decl
	;

decl ::=  IDENTIFIER:id COLON type:t SEMIC
{:
	if(Main.currentNode != null)
	{
		Main.currentNode.getEnvironment().put(id, t);
		System.out.println("ENV : " + Main.currentNode.getEnvironment().toString());
	}
	else
		System.out.println("DÉCLARATION VARIABLE GLOBALE INTERDITE!! FAUT GÉRER CA ICI!");
:} ;

functDecls ::=
	functDecls:l COMMA functDecl:f
	{:
		l.add(f);
		RESULT = l;
	:}
	| functDecl:f 
	{: 
		LinkedList<ArgumentInfo> l = new LinkedList<ArgumentInfo>();
		l.add(f);
		RESULT = l;  
	:}
	;

functDecl ::=  IDENTIFIER:id COLON type:t {: RESULT = new ArgumentInfo(id, t); :} ;
		
	/*	
notee ::=
   IF THEN ELSE WHILE DO OF  LPAR RPAR LBRACE RBRACE LBRACKET RBRACKET SEMIC COLON AFF AND OR LT GT LE GE EQ DIFF PLUS MINUS MINUS_U MULT DIV
    INT FLOAT STRING CHAR FUNCTION LIST TRUE FALSE COMMA STRUCT SLOT MODULO TO REPEAT BOOL CASE
    {::};*/
    
    
    
    