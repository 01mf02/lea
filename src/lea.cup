package lea;
 
import java_cup.runtime.*;
import java.io.*;
import java.lang.*;
import java.util.*;
import lea.types.*;
import lea.constants.*;
import lea.syntax.*;

    
terminal SEMIC,PROCEDURE, FUNCTION, LBRACKET, RBRACKET, LPAR, RPAR ,COLON, LBRACE, RBRACE, INT, FLOAT,LIST,OF,STRUCT, STRING, CHAR, BOOL,COMMA;
terminal IF, ELSE, CASE,IN;
terminal WHILE, REPEAT,FOR;
terminal AFF, SLOT, TO;
terminal RETURN;
terminal AND, OR, LT, GT, LE, GE, EQ, DIFF;
terminal PLUS, MINUS, MINUS_U, MULT, DIV, MODULO;

terminal String IDENTIFIER, INTEGER, FLOATEXP, STRINGEXP, CHAREXP, TRUEEXP, FALSEEXP;

non terminal axiom,constDecl,funct,procedure,struct,structDecls, structDecl,erreur;
non terminal Instruction decl;
non terminal Type type;
non terminal LinkedList<ArgumentInfo> functDecls;
non terminal ArgumentInfo functDecl;
non terminal SyntaxTree block;
non terminal Instruction instrs, instr;
non terminal Expression expr;
non terminal String BOOLEXP;
non terminal Expression variable;

precedence left COMMA;
precedence right ELSE;
precedence left AND;
precedence left OR;
precedence left LT, GT, LE, GE, EQ, DIFF;
precedence left PLUS, MINUS;
precedence left MULT, DIV, MODULO;
precedence left MINUS_U;
precedence left SLOT;

start with axiom;

axiom ::= 
		funct
		| funct axiom
		| procedure
		| procedure axiom
		| constDecl axiom
		| constDecl	
		| struct axiom
		| struct
		| erreur axiom
		| erreur
		;
		
		
erreur ::= 
		error SEMIC
		{:
			Main.printError("\n point-virgule ( ; ) manquant à la fin d'une ligne. \n", 1);
		:}
		| error RBRACE
		{:
			Main.printError("\n Accolade droite ( } ) manquante \n", 1);
		:}
		| error LPAR
		{:
			Main.printError("\n Parenthèse droite ( ) ) manquante \n", 1);
		:}
		;		
		
		
type ::=
		INT {: RESULT = new IntType();  :}
		| FLOAT {: RESULT = new FloatType();  :}
		| type:t1 COMMA type:t2 {: RESULT = new TupleType(t1, t2); :} 
		| CHAR   {: RESULT = new CharType(); :}
		| STRING  {: RESULT = new StringType(); :}
		| BOOL {: RESULT = new BoolType(); :}
		| LIST OF type:t {: RESULT = new ListType(t); :}
		| IDENTIFIER:t 
		{:
			Type type = Main.typeTable.get(t);
			
			if(type == null)
			{
				Main.printError("Type non trouvable : " + t, 1);
			}			
			
			RESULT = type;
		:}
		;
		
		
constDecl ::= 
		IDENTIFIER:id EQ INTEGER:i SEMIC
		{:
		  	Main.constTable.put(id, new IntConstant(i));
		  	//System.out.println("\nCONST : " + Main.constTable.toString() + "\n");
		:}
		;
		
		
block ::=
		LBRACE
		{:
		    //System.out.println("BLOCK");
		    SyntaxTree sTree = new SyntaxTree(null, null);
		    
		    sTree.setEnvironment(Main.currentNode.getEnvironment());
		    if(!sTree.getFirstEnvironment().isEmpty())
		    	sTree.pushEnvironment(new Environment());
		    
		    Main.currentNode = sTree;
		:}  instrs:i RBRACE {: RESULT = i; Main.currentNode.popEnvironment(); :}
		;


decl ::=  IDENTIFIER:id COLON type:t SEMIC
		{:
			if(Main.currentNode != null)
			{
				boolean initialized = false;
				
				if(t instanceof ListType || t instanceof StructType)
					initialized = true;
				
				Main.currentNode.getFirstEnvironment().put(id, new VariableInfo(t, initialized));
				//System.out.println("ENV : \n" + Main.currentNode.getEnvironment().toString());
			}
				
			RESULT = new Assignment(new VariableLeaf(id, t), null);
		:}
		| IDENTIFIER:id COLON type:t AFF expr:e SEMIC
		{:
			if(Main.currentNode != null)
			{
				Main.currentNode.getFirstEnvironment().put(id, new VariableInfo(t, true));
				
				//System.out.println("ENV : \n" + Main.currentNode.getEnvironment().toString());
				RESULT = new Assignment(new VariableLeaf(id, t), e); 
			}
			
			if(!t.equals(e.getType()))
				Main.printError("Types incompatibles", 1);
		:} 
		/*|erreur %prec
		{::}*/
		;


structDecls ::= structDecls structDecl | structDecl | erreur;


structDecl ::=  IDENTIFIER:id COLON type:t SEMIC
		{:
			if(Main.currentNode != null)
			{
				Main.currentNode.getFirstEnvironment().put(id, new VariableInfo(t, false));
				//System.out.println("ENV : \n" + Main.currentNode.getEnvironment().toString());
			}
				
			RESULT = new Assignment(new VariableLeaf(id, t), null);
		:};


struct ::= IDENTIFIER:id EQ STRUCT 
		 {:
		    SyntaxTree sTree = new SyntaxTree(null, null);
		    
		    Main.currentNode = sTree;
		    Main.typeTable.put(id,new StructType(id));
		:}LBRACE structDecls RBRACE 
		{:
			StructType st = (StructType)Main.typeTable.get(id);
			st.setEnvironment(Main.currentNode.getFirstEnvironment());
		:}
		;


BOOLEXP ::=
		TRUEEXP:t {:RESULT = t; :}
		|FALSEEXP:t {:RESULT = t; :};


funct ::= 
		FUNCTION IDENTIFIER:id LPAR {: Main.currentNode = new SyntaxTree(null, null); :} functDecls:f RPAR COLON type:t block:b
		{:
			FunctionInfo fctInfo = new FunctionInfo(f, t, b);
			Main.fctTable.put(id, fctInfo);
			
			if(!b.containsReturn())
				Main.printError("La fonction " + id + " doit retourner une valeur!", 1);
				
			System.out.println("\n\nFCT : " + Main.fctTable.toString() + "\n");
		:}
		|FUNCTION IDENTIFIER:id LPAR RPAR COLON type:t {: Main.currentNode = new SyntaxTree(null, null); :} block:b
		{:
			LinkedList<ArgumentInfo> l = new LinkedList<ArgumentInfo>();
			FunctionInfo fctInfo = new FunctionInfo(l, t, b);
			Main.fctTable.put(id, fctInfo);
			
			if(!b.containsReturn())
				Main.printError("La fonction " + id + " doit retourner une valeur!", 1);
			
			System.out.println("\n\nFCT : " + Main.fctTable.toString() + "\n");
		:}
		;
		
		
procedure ::= 
		PROCEDURE IDENTIFIER:id LPAR {: Main.currentNode = new SyntaxTree(null, null); :} functDecls:f RPAR block:b
		{:
			FunctionInfo fctInfo = new FunctionInfo(f, null, b);
			Main.fctTable.put(id, fctInfo);
			
			System.out.println("\n\nPROCEDURE : " + Main.fctTable.toString() + "\n");
		:}
		|PROCEDURE IDENTIFIER:id LPAR RPAR  {: Main.currentNode = new SyntaxTree(null, null); :} block:b
		{:
			LinkedList<ArgumentInfo> l = new LinkedList<ArgumentInfo>();
			FunctionInfo fctInfo = new FunctionInfo(l, null, b);
			Main.fctTable.put(id, fctInfo);
			
			System.out.println("\n\nPROCEDURE : " + Main.fctTable.toString() + "\n");
		:}
		;

		
functDecls ::=
		functDecls:l COMMA functDecl:f
		{:
			l.add(f);
			RESULT = l;
		:}
		| functDecl:f 
		{: 
			LinkedList<ArgumentInfo> l = new LinkedList<ArgumentInfo>();
			l.add(f);
			RESULT = l;  
		:}
		;


functDecl ::=  IDENTIFIER:id COLON type:t {: Main.currentNode.getFirstEnvironment().put(id, new VariableInfo(t, true));  RESULT = new ArgumentInfo(id, t); :} ;
		
		
instr ::= 
		IF LPAR expr:e RPAR block:i1 ELSE block:i2  {: RESULT = new Condition(e, new ElseCondition(i1, i2)); :}
		| IF LPAR expr:e RPAR block:i   {: RESULT = new Condition(e, i); :}
		| REPEAT TO CASE
		| FOR IDENTIFIER:i IN LBRACKET TO RBRACKET LBRACE block:b RBRACE
		| variable:v AFF expr:e SEMIC 
		{: 
			if(v.getType() != null && e.getType() != null)
			{
				if(!v.getType().equals(e.getType()))
					Main.printError("Types incompatibles", 1);
					
				if(v instanceof VariableLeaf)
				{
					VariableLeaf vl = (VariableLeaf)v;
					VariableInfo vi = Main.currentNode.findInEnvironment(vl.getName());
					
					if(vi != null)
						vi.initialize();
				}
				else if(v instanceof StructAccessor)
				{
					 StructAccessor sa = (StructAccessor)v;
					 sa.initializeVar();
				}
				
				RESULT = new Assignment(v, e); 
			}
		:}
		| REPEAT block:b WHILE LPAR expr:e RPAR 
		{: RESULT = new Loop(e, b); :}
		| decl:d {: RESULT = d;	:}
		| RETURN expr:e SEMIC {: RESULT = new  ReturnNode(e);:}
		| erreur 
		{:
			//Cr√©e un objet global pour les erreurs?
			RESULT = new Instruction(null,null);
		:}
		;


instrs ::= 
		instrs:i1 instr:i2   {: RESULT = new Succ(i1, i2); :}
		| instr:i  {: RESULT = i; :}
		;


expr ::=
		expr:e1 AND expr:e2 
		{:
			if(!e1.getType().equals(new BoolType()) || !e2.getType().equals(new BoolType()))
				Main.printError("Les types à gauche et à droite d'un && doivent être du type bool", 1);
				
			RESULT = new BoolExp(e1, e2, EnumTagExp.AND); 
		:} 
		|expr:e1 OR expr:e2
		{:
			if(!e1.getType().equals(new BoolType()) || !e2.getType().equals(new BoolType()))
				Main.printError("Les types à gauche et à droite d'un || doivent être du type bool", 1);
				
			RESULT = new BoolExp(e1, e2, EnumTagExp.OR); 
		:}
		|expr:e1 LT expr:e2 
		{:
			if(!e1.getType().equals(new IntType()) || !e2.getType().equals(new IntType()))
				Main.printError("Les types à gauche et à droite d'un < doivent être du type entier ou réel", 1);
				
			RESULT = new BoolExp(e1, e2, EnumTagExp.LT); 
		:} 
		|expr:e1 GT expr:e2
		{:
			if(!e1.getType().equals(new IntType()) || !e2.getType().equals(new IntType()))
				Main.printError("Les types à gauche et à droite d'un <= doivent être du type entier ou réel", 1);
				
			RESULT = new BoolExp(e1, e2, EnumTagExp.GT); 
		:} 
		|expr:e1 LE expr:e2 
		{:
			if(!e1.getType().equals(new IntType()) || !e2.getType().equals(new IntType()))
				Main.printError("Les types à gauche et à droite d'un > doivent être du type entier ou réel", 1);
				
			RESULT = new BoolExp(e1, e2, EnumTagExp.LE); 
		:} 
		|expr:e1 GE expr:e2 
		{:
			if(!e1.getType().equals(new IntType()) || !e2.getType().equals(new IntType()))
				Main.printError("Les types à gauche et à droite d'un >= doivent être du type entier ou réel", 1);
				
			RESULT = new BoolExp(e1, e2, EnumTagExp.GE); 
		:}  
		|expr:e1 EQ expr:e2 
		{: 
			if(!e1.getType().equals(e2.getType())) 
				Main.printError("Les types à gauche et à droite d'un = doivent être du même type", 1);
				
			RESULT = new BoolExp(e1, e2, EnumTagExp.EQ); 
		:} 
		|expr:e1 DIFF expr:e2 
		{: 
			if(!e1.getType().equals(e2.getType())) 
				Main.printError("Les types à gauche et à droite d'un != doivent être du même type", 1);
			
			RESULT = new BoolExp(e1, e2, EnumTagExp.DIFF); 
		:} 
		|expr:e1 PLUS expr:e2 
		{: 
			if(!e1.getType().equals(e2.getType()) && !e1.getType().equals(new IntType()) && !e1.getType().equals(new StringType())) 
				Main.printError("Les types à gauche et à droite d'un + doivent être du même type et soit entier, réel ou chaîne de caractères", 1);
				
			RESULT = new NumberExp(e1, e2, EnumTagExp.PLUS); 
		:} 
		|expr:e1 MINUS expr:e2
		{: 
			if(!e1.getType().equals(e2.getType()) && !e1.getType().equals(new IntType())) 
				Main.printError("Les types à gauche et à droite d'un - doivent être du même type et soit entier ou réel", 1);
			
			RESULT = new NumberExp(e1, e2, EnumTagExp.MINUS); 
		:} 
		|MINUS expr:e
		{: 
			if(!e.getType().equals(new IntType())) 
				Main.printError("Le type à droite d'un - doit être un entier ou un réel", 1);
			
			RESULT = new NumberExp(e, null, EnumTagExp.MINUS_U); 	
		:} %prec MINUS_U 
		|expr:e1 MULT expr:e2
		{: 
			if(!e1.getType().equals(e2.getType()) && !e1.getType().equals(new IntType())) 
				Main.printError("Les types à gauche et à droite d'un * doivent être du même type et soit entier ou réel", 1);
			
			RESULT = new NumberExp(e1, e2, EnumTagExp.MULT); 
		:} 
		|expr:e1 DIV expr:e2
		{: 
			if(!e1.getType().equals(e2.getType()) && !e1.getType().equals(new IntType())) 
				Main.printError("Les types à gauche et à droite d'un / doivent être du même type et soit entier ou réel", 1);
			
			RESULT = new NumberExp(e1, e2, EnumTagExp.DIV); 
		:} 
		|expr:e1 MODULO expr:e2
		{: 
			if(!e1.getType().equals(e2.getType()) && !e1.getType().equals(new IntType())) 
				Main.printError("Les types à gauche et à droite d'un % doivent être du même type et soit entier ou réel", 1);
			
			RESULT = new NumberExp(e1, e2, EnumTagExp.MOD); 
		:} 
		|LPAR expr:e RPAR {: RESULT = e; :}
		|INTEGER:it {: 
			RESULT = new ConstantLeaf(new IntConstant(it)); 
			:}
		|FLOATEXP:d {: 
			RESULT = new ConstantLeaf(new FloatConstant(d)); 
			:}
		|STRINGEXP:st {: 
			RESULT = new ConstantLeaf(new StringConstant(st));  
			:}
		|CHAREXP:c {: 
			RESULT = new ConstantLeaf(new CharConstant(c));  
			:}
		|variable:v 
		{: 
			if(v instanceof VariableLeaf)
			{
				VariableLeaf vl = (VariableLeaf)v;
				VariableInfo vi = Main.currentNode.findInEnvironment(vl.getName());
				
				if(vi != null && !vi.initialized())
					Main.printError("Variable non initialisée : " + vl.getName(), 0);
			}
			else if(v instanceof StructAccessor)
			{
				StructAccessor sa = (StructAccessor)v;
				if(!sa.isVarInitialized())
					Main.printError("Variable non initialisée : " + sa.toVariableString(), 0);
			}
			
			RESULT = v; 
		:}
		|BOOLEXP:b {: 
			RESULT = new ConstantLeaf(new BoolConstant(b)); 
			:}
		| expr:e1 COMMA expr:e2 
		{: 
			RESULT = new ListNode(new Expression(e1, e2)); 
		:}
		;
	
	
variable ::=
    	IDENTIFIER:id 
    	{:    		
    		//TODO MHB : RAISE ERROR IF t & c == null
    		Constant c = Main.constTable.get(id);
    		
    		if(c == null)
    		{
    			VariableInfo vi = Main.currentNode.findInEnvironment(id);
    			
				if(vi != null)
				{
					Type t = vi.getType();
					RESULT = new VariableLeaf(id, t);
				}
				else
				{
					Main.printError("La variable ou la constante " + id + " n'a pas été trouvée", 1);
					RESULT = new VariableLeaf(id + " NOT FOUND", null);
				}
    		}
    		else
    			RESULT = new ConstantLeaf(c);
    	:}
    	| variable:v SLOT 
    	{:
    		if(v.getType() instanceof StructType)
    		{     		
    			StructType st = (StructType)v.getType();    			 
				Main.currentNode.pushEnvironment(st.getEnvironment()); 
			}
		:} 
		variable:v1 
		{:    	
    		if(v.getType() instanceof StructType)
    		{
	    		StructType st = (StructType)v.getType();
				VariableInfo vi = st.getEnvironment().get(((VariableLeaf)v1).getName());
				
				Main.currentNode.popEnvironment();
				
				RESULT = new StructAccessor(v, v1);
    		}
    	:}
    	| IDENTIFIER:id LPAR expr:e RPAR
    	{:
    		FunctionInfo info = Main.fctTable.get(id);
    		if(info != null)
    		{
    			RESULT = new FunctionCall( new FunctionRef(id, info), e);
    		}
			else
			{
				Main.printError("Fonction "+id+" introuvable!", 1);
			}
    	:}
    	| variable:v LBRACKET expr:e RBRACKET
    	{:
    		boolean isOk = false;
    		
    		if(v instanceof VariableLeaf || v instanceof ListAccessor || v instanceof StructAccessor)
    		{
    			if(v.getType() instanceof ListType)
    			{
		    		if(e.getType().equals(new IntType()))
	    			{
	    				RESULT = new ListAccessor(v, e);
	    				isOk = true;
	    			}
	    		}
    		}
    			//error dans tous les autres cas
    		if(!isOk)
    		{
    			Main.printError("Accesseur à la liste impossible, mauvais type", 1);
    		}
    	:}
		;
	
    
  /**Liste de TODO
  tuples
  retour fonction
  fonction sans decls
  */
  
  
  
  
  
  
  
  
  
  
  
  
   
    