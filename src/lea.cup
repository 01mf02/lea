package lea;
 
import java_cup.runtime.*;
import java.io.*;
import java.lang.*;
import java.util.*;
import lea.types.*;
import lea.constants.*;
import lea.syntax.*;

    
terminal SEMIC,PROCEDURE, FUNCTION, LBRACKET, RBRACKET, LPAR, RPAR ,COLON, LBRACE, RBRACE, INT, FLOAT,LIST,OF,STRUCT, STRING, CHAR, BOOL,COMMA;
terminal IF, ELSE, CASE,IN;
terminal WHILE, REPEAT,FOR;
terminal AFF, SLOT, TO;
terminal RETURN;
terminal AND, OR, LT, GT, LE, GE, EQ, DIFF;
terminal PLUS, MINUS, MINUS_U, MULT, DIV, MODULO;

terminal String IDENTIFIER, INTEGER, FLOATEXP, STRINGEXP, CHAREXP, TRUEEXP, FALSEEXP;

non terminal axiom,constDecl,funct,procedure,struct,structDecls, structDecl,erreur;
non terminal Instruction decl;
non terminal Type type,tupleType;
non terminal LinkedList<ArgumentInfo> functDecls;
non terminal ArgumentInfo functDecl;
non terminal SyntaxTree block;
non terminal Instruction instrs, instr;
non terminal Expression expr;
non terminal String BOOLEXP;
non terminal Expression variable,functCall;

precedence left COMMA;
precedence right ELSE;
precedence left AND;
precedence left OR;
precedence left LT, GT, LE, GE, EQ, DIFF;
precedence left PLUS, MINUS;
precedence left MULT, DIV, MODULO;
precedence left MINUS_U;
precedence left SLOT;

start with axiom;

axiom ::= 
		funct
		| funct axiom
		| procedure
		| procedure axiom
		| constDecl axiom
		| constDecl	
		| struct axiom
		| struct
		| erreur axiom
		| erreur
		;
		
		
erreur ::= 
		error SEMIC
		{:
			Main.printError("\";\" is missing \n", 1);
		:}
		| error RBRACE
		{:
			Main.printError("\"}\" is missing \n", 1);
		:}
		| error LPAR
		{:
			Main.printError("\"(\" is missing \n", 1);
		:}
		;		
		
		
tupleType ::= 
		tupleType:t1 COMMA type:t2 {: RESULT = new TupleType(t1, t2); :}
		|type:t1 {: RESULT = t1; :}
		;
		
		
type ::=
		INT {: RESULT = new IntType();  :}
		| FLOAT {: RESULT = new FloatType();  :}
		| LPAR tupleType:t RPAR {: RESULT = t;  :}
		| CHAR   {: RESULT = new CharType(); :}
		| STRING  {: RESULT = new StringType(); :}
		| BOOL {: RESULT = new BoolType(); :}
		| LIST OF type:t {: RESULT = new ListType(t); :}
		| IDENTIFIER:t 
		{:
			Type type = Main.typeTable.get(t);
			
			if(type == null)
			{
				Main.printError("Type non trouvable : " + t, 1);
			}			
			
			RESULT = type;
		:}
		;
		
		
constDecl ::= 
		IDENTIFIER:id EQ INTEGER:i SEMIC
		{:
			if(Main.constTable.containsKey(id))
			{
				Main.printError("Constant already declared : " + id, 1);
			}
			else
			{
				Main.constTable.put(id, new IntConstant(i));
			}
		:}
		;
		
		
block ::=
		LBRACE
		{:
		    //System.out.println("BLOCK");
		    SyntaxTree sTree = new SyntaxTree(null, null);
		    
		    sTree.setEnvironment(Main.currentNode.getEnvironment());
		    if(!sTree.getFirstEnvironment().isEmpty())
		    	sTree.pushEnvironment(new Environment());
		    
		    Main.currentNode = sTree;
		:}  instrs:i RBRACE {: RESULT = i; Main.currentNode.popEnvironment(); :}
		| LBRACE RBRACE {: RESULT = new Instruction(null,null); :}
		;


decl ::=  IDENTIFIER:id COLON type:t SEMIC
		{:
			if(Main.currentNode != null)
			{
				boolean initialized = false;
				
				if(t instanceof ListType || t instanceof StructType)
					initialized = true;
				
				Main.currentNode.getFirstEnvironment().put(id, new VariableInfo(t, initialized));
				//System.out.println("ENV : \n" + Main.currentNode.getEnvironment().toString());
			}
				
			RESULT = new Assignment(new VariableLeaf(id, t), null);
		:}
		| IDENTIFIER:id COLON type:t AFF expr:e SEMIC
		{:
			if(Main.currentNode != null)
			{
				Main.currentNode.getFirstEnvironment().put(id, new VariableInfo(t, true));
				
				//System.out.println("ENV : \n" + Main.currentNode.getEnvironment().toString());
				RESULT = new Assignment(new VariableLeaf(id, t), e); 
			}
			
			if(!t.equals(e.getType()))
				Main.printError("Types incompatibles", 1);
		:} 
		;


structDecls ::= structDecls structDecl | structDecl | erreur;


structDecl ::=  IDENTIFIER:id COLON type:t SEMIC
		{:
			if(Main.currentNode != null)
			{
				Main.currentNode.getFirstEnvironment().put(id, new VariableInfo(t, false));
				//System.out.println("ENV : \n" + Main.currentNode.getEnvironment().toString());
			}
				
			RESULT = new Assignment(new VariableLeaf(id, t), null);
		:};


struct ::= IDENTIFIER:id EQ STRUCT 
		 {:
		    SyntaxTree sTree = new SyntaxTree(null, null);
		    
		    Main.currentNode = sTree;
		    Main.typeTable.put(id,new StructType(id));
		:}LBRACE structDecls RBRACE 
		{:
			StructType st = (StructType)Main.typeTable.get(id);
			st.setEnvironment(Main.currentNode.getFirstEnvironment());
		:}
		;


BOOLEXP ::=
		TRUEEXP:t {:RESULT = t; :}
		|FALSEEXP:t {:RESULT = t; :};


funct ::=
		FUNCTION IDENTIFIER:id LPAR {: Main.currentNode = new SyntaxTree(null, null); :} functDecls:f RPAR COLON type:t block:b
		{:
			FunctionInfo fctInfo = new FunctionInfo(f, t, b);
			Main.fctTable.put(id, fctInfo);
			
			if(!b.containsReturn())
				Main.printError("La fonction " + id + " doit retourner une valeur!", 1);
				
			System.out.println("\n\nFCT : " + Main.fctTable.toString() + "\n");
		:}
		|FUNCTION IDENTIFIER:id LPAR RPAR COLON type:t {: Main.currentNode = new SyntaxTree(null, null); :} block:b
		{:
			LinkedList<ArgumentInfo> l = new LinkedList<ArgumentInfo>();
			FunctionInfo fctInfo = new FunctionInfo(l, t, b);
			Main.fctTable.put(id, fctInfo);
			
			if(!b.containsReturn())
				Main.printError("La fonction " + id + " doit retourner une valeur!", 1);
			
			System.out.println("\n\nFCT : " + Main.fctTable.toString() + "\n");
		:}
		;
		
		
procedure ::= 
		PROCEDURE IDENTIFIER:id LPAR {: Main.currentNode = new SyntaxTree(null, null); :} functDecls:f RPAR block:b
		{:
			FunctionInfo fctInfo = new FunctionInfo(f, null, b);
			Main.fctTable.put(id, fctInfo);
			
			System.out.println("\n\nPROCEDURE : " + Main.fctTable.toString() + "\n");
		:}
		|PROCEDURE IDENTIFIER:id LPAR RPAR  {: Main.currentNode = new SyntaxTree(null, null); :} block:b
		{:
			LinkedList<ArgumentInfo> l = new LinkedList<ArgumentInfo>();
			FunctionInfo fctInfo = new FunctionInfo(l, null, b);
			Main.fctTable.put(id, fctInfo);
			
			System.out.println("\n\nPROCEDURE : " + Main.fctTable.toString() + "\n");
		:}
		;

		
functDecls ::=
		functDecls:l COMMA functDecl:f
		{:
			l.add(f);
			RESULT = l;
		:}
		| functDecl:f 
		{: 
			LinkedList<ArgumentInfo> l = new LinkedList<ArgumentInfo>();
			l.add(f);
			RESULT = l;  
		:}
		;


functDecl ::=  IDENTIFIER:id COLON type:t 
		{: 
			Main.currentNode.getFirstEnvironment().put(id, new VariableInfo(t, true));  
			RESULT = new ArgumentInfo(id, t); 
		:} 
		;
		
		
instr ::= 
		IF LPAR expr:e RPAR block:i1 ELSE block:i2  {: RESULT = new Condition(e, new ElseCondition(i1, i2)); :}
		| IF LPAR expr:e RPAR block:i   {: RESULT = new Condition(e, i); :}
		| REPEAT TO CASE
		| FOR IDENTIFIER:i IN LBRACKET TO RBRACKET LBRACE block:b RBRACE
		| variable:v AFF LBRACKET expr:e RBRACKET SEMIC 
		{: 
			//TODO : Gestion des types list vs tuples
			if(v.getType() != null && e.getType() != null)
			{
				if(v.getType() instanceof ListType)
				{
					if(!v.getType().equals(e.getType()))
					{
		
						Main.printError("Types incompatibles "  + e.getType(), 1);
					}
				}
				else
				{
					Main.printError(v+ " is not of type list", 1);			
				}							
					
				RESULT = new Assignment(v, e); 
			}
		:}
		| variable:v AFF expr:e SEMIC 
		{: 
			if(v.getType() != null && e.getType() != null)
			{
				if(true || !(v.getType() instanceof TupleType))
				{
					if(!v.getType().equals(e.getType()))
					{
						Main.printError("Types incompatibles"  + v.getType().toString(), 1);
					}
				}
				else
				{
						
				}				
					
					
				if(v instanceof VariableLeaf)
				{
					VariableLeaf vl = (VariableLeaf)v;
					VariableInfo vi = Main.currentNode.findInEnvironment(vl.getName());
					
					if(vi != null)
						vi.initialize();
				}
				else if(v instanceof StructAccessor)
				{
					 StructAccessor sa = (StructAccessor)v;
					 sa.initializeVar();
				}
				
				RESULT = new Assignment(v, e); 
			}
		:}
		| WHILE LPAR expr:e RPAR block:b
		{:
		//Distinguer while et repeat
			if(e.getType() instanceof BoolType)
			{
				RESULT = new Loop(e, b); 
			} 
			else
			{
				Main.printError("Expression must be a boolean", 1);
			}
		:}
		| REPEAT block:b WHILE LPAR expr:e RPAR 
		{:
			if(e.getType() instanceof BoolType)
			{
				RESULT = new Loop(e, b); 
			} 
			else
			{
				Main.printError("Expression must be a boolean", 1);
			}
		:}
		| decl:d {: RESULT = d;	:}
		| variable:v SEMIC {: //Main.printError("Salut! " + v.toString(), 0); 
		:}
		| RETURN expr:e SEMIC {: 
			if(Main.currentNode.getType() == e.getType() )
			{
				RESULT = new  ReturnNode(e);
			}	 
			else
			{
				Main.printError("The return must be of type " + Main.currentNode.getType(), 1);
			}
		:}
		| RETURN  SEMIC {:
			if(Main.currentNode.getType() == null )
			{
				RESULT = new  ReturnNode(null);
			}	 
			else
			{
				Main.printError("Procedure can't return value", 1);
			}
		 :}
		| erreur 
		{:
			//Crée un objet global pour les erreurs?
			RESULT = new Instruction(null,null);
		:}
		;


instrs ::= 
		instrs:i1 instr:i2   {: RESULT = new Succ(i1, i2); :}
		| instr:i  {: RESULT = i; :}
		;


expr ::=
		expr:e1 AND expr:e2 
		{:
			if(!e1.getType().equals(new BoolType()) || !e2.getType().equals(new BoolType()))
				Main.printError("Les types � gauche et � droite d'un && doivent �tre du type bool", 1);
				
			RESULT = new BoolExp(e1, e2, EnumTagExp.AND); 
		:} 
		|expr:e1 OR expr:e2
		{:
			if(!e1.getType().equals(new BoolType()) || !e2.getType().equals(new BoolType()))
				Main.printError("Les types � gauche et � droite d'un || doivent �tre du type bool", 1);
				
			RESULT = new BoolExp(e1, e2, EnumTagExp.OR); 
		:}
		|expr:e1 LT expr:e2 
		{:
			if(!e1.getType().equals(new IntType()) || !e2.getType().equals(new IntType()))
				Main.printError("Les types � gauche et � droite d'un < doivent �tre du type entier ou r�el", 1);
				
			RESULT = new BoolExp(e1, e2, EnumTagExp.LT); 
		:} 
		|expr:e1 GT expr:e2
		{:
			if(!e1.getType().equals(new IntType()) || !e2.getType().equals(new IntType()))
				Main.printError("Les types � gauche et � droite d'un <= doivent �tre du type entier ou r�el", 1);
				
			RESULT = new BoolExp(e1, e2, EnumTagExp.GT); 
		:} 
		|expr:e1 LE expr:e2 
		{:
			if(!e1.getType().equals(new IntType()) || !e2.getType().equals(new IntType()))
				Main.printError("Les types � gauche et � droite d'un > doivent �tre du type entier ou r�el", 1);
				
			RESULT = new BoolExp(e1, e2, EnumTagExp.LE); 
		:} 
		|expr:e1 GE expr:e2 
		{:
			if(!e1.getType().equals(new IntType()) || !e2.getType().equals(new IntType()))
				Main.printError("Les types � gauche et � droite d'un >= doivent �tre du type entier ou r�el", 1);
				
			RESULT = new BoolExp(e1, e2, EnumTagExp.GE); 
		:}  
		|expr:e1 EQ expr:e2 
		{: 
			if(!e1.getType().equals(e2.getType())) 
				Main.printError("Les types � gauche et � droite d'un = doivent �tre du m�me type", 1);
				
			RESULT = new BoolExp(e1, e2, EnumTagExp.EQ); 
		:} 
		|expr:e1 DIFF expr:e2 
		{: 
			if(!e1.getType().equals(e2.getType())) 
				Main.printError("Les types � gauche et � droite d'un != doivent �tre du m�me type", 1);
			
			RESULT = new BoolExp(e1, e2, EnumTagExp.DIFF); 
		:} 
		|expr:e1 PLUS expr:e2 
		{: 
			if(!e1.getType().equals(e2.getType()) || !e1.getType().equals(new IntType()) && !e1.getType().equals(new StringType())) 
				Main.printError("Les types � gauche et � droite d'un + doivent �tre du m�me type et soit entier, r�el ou cha�ne de caract�res", 1);
				
			RESULT = new NumberExp(e1, e2, EnumTagExp.PLUS); 
		:} 
		|expr:e1 MINUS expr:e2
		{: 
			if(!e1.getType().equals(e2.getType()) || !e1.getType().equals(new IntType())) 
				Main.printError("Les types � gauche et � droite d'un - doivent �tre du m�me type et soit entier ou r�el", 1);
			
			RESULT = new NumberExp(e1, e2, EnumTagExp.MINUS); 
		:} 
		|MINUS expr:e
		{: 
			if(!e.getType().equals(new IntType())) 
				Main.printError("Le type � droite d'un - doit �tre un entier ou un r�el", 1);
			
			RESULT = new NumberExp(e, null, EnumTagExp.MINUS_U); 	
		:} %prec MINUS_U 
		|expr:e1 MULT expr:e2
		{: 
			if(!e1.getType().equals(e2.getType()) || !e1.getType().equals(new IntType())) 
				Main.printError("Les types � gauche et � droite d'un * doivent �tre du m�me type et soit entier ou r�el", 1);
			
			RESULT = new NumberExp(e1, e2, EnumTagExp.MULT); 
		:} 
		|expr:e1 DIV expr:e2
		{: 
			if(!e1.getType().equals(e2.getType()) || !e1.getType().equals(new IntType())) 
				Main.printError("Les types � gauche et � droite d'un / doivent �tre du m�me type et soit entier ou r�el", 1);
			
			RESULT = new NumberExp(e1, e2, EnumTagExp.DIV); 
		:} 
		|expr:e1 MODULO expr:e2
		{: 
			if(!e1.getType().equals(e2.getType()) || !e1.getType().equals(new IntType())) 
				Main.printError("Les types � gauche et � droite d'un % doivent �tre du m�me type et soit entier ou r�el", 1);
			
			RESULT = new NumberExp(e1, e2, EnumTagExp.MOD); 
		:} 
		| expr:e1 COMMA expr:e2 
		{: 	
			//Main.printError("Les " + e1.getType().toString() + "Les " +e2.getType().toString() + " jj j ", 1);
			//RESULT = new ListNode(new Expression(e1, e2)); 
			RESULT = new ListNode(e1, e2);
			//RESULT = new TupleConstant();
		:}
		//| LBRACKET expr:e LBRACKET {: RESULT = e; :}
		|LPAR expr:e RPAR {: RESULT = e; :}
		|INTEGER:it {: 
			RESULT = new ConstantLeaf(new IntConstant(it)); 
			:}
		|FLOATEXP:d {: 
			RESULT = new ConstantLeaf(new FloatConstant(d)); 
			:}
		|STRINGEXP:st {: 
			RESULT = new ConstantLeaf(new StringConstant(st));  
			:}
		|CHAREXP:c {: 
			RESULT = new ConstantLeaf(new CharConstant(c));  
			:}
		|variable:v 
		{: 
			if(v instanceof VariableLeaf)
			{
				VariableLeaf vl = (VariableLeaf)v;
				VariableInfo vi = Main.currentNode.findInEnvironment(vl.getName());
				
				if(vi != null && !vi.initialized())
					Main.printError("Variable non initialis�e : " + vl.getName(), 0);
			}
			else if(v instanceof StructAccessor)
			{
				StructAccessor sa = (StructAccessor)v;
				if(!sa.isVarInitialized())
					Main.printError("Variable non initialis�e : " + sa.toVariableString(), 0);
			}
			
			RESULT = v; 
		:}
		|BOOLEXP:b {: 
			RESULT = new ConstantLeaf(new BoolConstant(b)); 
			:}
		;

//Jcrois inutile
functCall ::= 
 		IDENTIFIER:id LPAR RPAR
    	{:
    		FunctionInfo info = Main.fctTable.get(id);
    		if(info != null)
    		{
    			RESULT = new FunctionCall( new FunctionRef(id, info), null);
    		}
			else
			{
				NativeFunctionInfo nfi = Main.nativeFctTable.get(id);
				if(nfi == null)
					Main.printError("Fonction "+id+" introuvable!", 1);
				else
				{
					if(!Main.nativeFctTable.isCallPermitted(id, null, null))
					{
						Main.printError("Fonction "+id+" introuvable ou appel�e incorrectement", 1);
					}
					else
					{
						RESULT = new FunctionCall(new FunctionRef(id, nfi), null);
					}
				}
			}
    	:}
		| IDENTIFIER:id LPAR expr:e RPAR
    	{:
    		FunctionInfo info = Main.fctTable.get(id);
    		if(info != null)
    		{
    			RESULT = new FunctionCall( new FunctionRef(id, info), e);
    		}
			else
			{
				NativeFunctionInfo nfi = Main.nativeFctTable.get(id);
				if(nfi == null)
					Main.printError("Fonction "+id+" introuvable!", 1);
				else
				{
					if(!Main.nativeFctTable.isCallPermitted(id, e, null))
					{
						Main.printError("Fonction "+id+" introuvable ou appel�e incorrectement", 1);
					}
					else
						RESULT = new FunctionCall(new FunctionRef(id, nfi), e);
				}
			}
    	:}
    	;
		
	
variable ::=
    	IDENTIFIER:id 
    	{:    		
    		Constant c = Main.constTable.get(id);
    		
    		if(c == null)
    		{
    			VariableInfo vi = Main.currentNode.findInEnvironment(id);
    			
				if(vi != null)
				{
					Type t = vi.getType();
					RESULT = new VariableLeaf(id, t);
				}
				else
				{
					Main.printError("La variable ou la constante " + id + " n'a pas �t� trouv�e", 1);
					RESULT = new VariableLeaf(id + " NOT FOUND", null);
				}
    		}
    		else
    			RESULT = new ConstantLeaf(c);
    	:}
    	| variable:v SLOT 
    	{:
    		if(v.getType() instanceof StructType)
    		{     		
    			StructType st = (StructType)v.getType();    			 
				Main.currentNode.pushEnvironment(st.getEnvironment()); 
			}
		:} 
		variable:v1 
		{:    	
    		if(v.getType() instanceof StructType)
    		{
	    		StructType st = (StructType)v.getType();
				VariableInfo vi = st.getEnvironment().get(((VariableLeaf)v1).getName());
				
				Main.currentNode.popEnvironment();
				
				RESULT = new StructAccessor(v, v1);
    		}
    		
    		if(v1 instanceof FunctionCall)
			{
			
			}
    	:}
    	| functCall:fc {: RESULT = fc;:}
    	| variable:v LBRACKET expr:e RBRACKET
    	{:
    		boolean isOk = false;
    		
    		if(v instanceof VariableLeaf || v instanceof ListAccessor || v instanceof StructAccessor)
    		{
    			if(v.getType() instanceof ListType)
    			{
		    		if(e.getType().equals(new IntType()))
	    			{
	    				RESULT = new ListAccessor(v, e);
	    				isOk = true;
	    			}
	    		}
    		}
    			//error dans tous les autres cas
    		if(!isOk)
    		{
    			Main.printError("Accesseur � la liste impossible, mauvais type", 1);
    		}
    	:}
		;
	
    
  /**Liste de TODO
  retour fonction
  gestion des commentaires accent
  function call comme du monde (peut �tre utilis� comme instruction aussi)
  */
  
  
  /*
  NOTES POUR PHIL (de Mic)
  Pour ce qui est des FunctionCall, je pense qu'il serait bien de les extraire de variable et d'en faire un cas a part parce que sinon
  on se complique trop la vie je pense...tu verras a ca! En gros writeln("toto") marche, mais pas encore le maListe.toString() ni read()
  Faut faire les boucles aussi, y'en manque pas mal a faire sur ce cote la! Pour les fonctions du systeme (writeln, read, toString, etc)
  J'ai fait une table de NativeFunctionTable et elle est testee, elle marche tres bien!
  
  On s'en reparle si tu as des questions!
  Note : check aussi fonctions a plusieurs parametres qui ne marchent pas! Merci^^
  */
   
    