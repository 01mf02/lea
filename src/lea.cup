package generated;
 
import java_cup.runtime.*;
import java.io.*;
import java.lang.*;
import java.util.*;
import generated.*;
import lea.*;
import lea.types.*;
import lea.constants.*;
import lea.syntax.*;

parser code
{:
	public ConstantTable getConstantTable() { return action_obj.constTable; }
	public TypeTable getTypeTable() { return action_obj.typeTable; }
	public FunctionTable getFunctionTable() { return action_obj.fctTable; }
	public NativeFunctionTable getNativeFunctionTable() { return action_obj.nativeFctTable; }

	private LeaLexer lexer;

	public LeaParser(LeaLexer lexer) {
		super(lexer);
		this.lexer = lexer;
	}

	public void printError(String message, int level) {
		lexer.printError(message, level);
	}

	public boolean hasCompileErrors() {
		return lexer.hasCompileErrors;
	}
:}

action code
{:
	public ConstantTable constTable = new ConstantTable();
	public TypeTable typeTable = new TypeTable();
	public FunctionTable fctTable = new FunctionTable();
	public NativeFunctionTable nativeFctTable = new NativeFunctionTable();

	private int enumID = 0;
	
	// Le noeud courant dans lequel on est rendu
	private SyntaxTree currentNode = null;
	
	// Les informations de la fonction que l'on traite
	private FunctionInfo functInfo = null;
	
	// Les informations pour connaitre le type de celui qui nous appelle
	private Type callerType = null;


	private BoolExp constructBoolExp(Expression e1, Expression e2, EnumTagExp op) {
		switch (op) {
			case AND:
			case OR:
				if(!e1.getType().equals(new BoolType()) || !e2.getType().equals(new BoolType()))
					parser.printError("The types on each side for operator " + op + " must be boolean. Got : " + e1.getType() + " X " +  e2.getType(), 1);
				break;

			case LT:
			case LE:
			case GT:
			case GE:
				if(!e1.getType().equals(e2.getType()) || (!(e1.getType().equals(new IntType())) && !(e1.getType().equals(new FloatType()))))
					parser.printError("The types on each side for operator " + op + " must be integer or real. Got : " + e1.getType() + " X " +  e2.getType(), 1);
				break;

			case EQ:
			case DIFF:
				if(!e1.getType().equals(e2.getType())) 
					parser.printError("The types on each side for operator " + op + " must be the same type. Got : " + e1.getType() + " X " +  e2.getType(), 1);
				break;

			default:
				parser.printError("Unrecognized operator!",1);
				break;
		}
				
		return new BoolExp(e1, e2, op);
	}

	private Expression constructNumberExp(Expression e1, Expression e2, EnumTagExp op) {
		switch (op) {
			case PLUS:
				if(!e1.getType().equals(e2.getType()) || (!(e1.getType().equals(new IntType())) && !(e1.getType().equals(new FloatType())) && !(e1.getType().equals(new StringType()))))
					parser.printError("The types on each side for operator + must be integer, real or string. Got : " + e1.getType() + " X " +  e2.getType(), 1);
				break;

			case MINUS:
			case MULT:
			case DIV:
				if(!e1.getType().equals(e2.getType()) || (!(e1.getType().equals(new IntType())) && !(e1.getType().equals(new FloatType()))))
					parser.printError("The types on each side for operator " + op + " must be an integer or a real. Got : " + e1.getType() + " X " +  e2.getType(), 1);
				break;

			case MINUS_U:
				if(!(e1.getType().equals(new IntType())) && !(e1.getType().equals(new FloatType())))
					parser.printError("The type on the right side for operator - must be an integer or a real", 1);
				break;
			
			case MOD:
				if(!e1.getType().equals(e2.getType()) || !e1.getType().equals(new IntType()))
					parser.printError("The types on each side for operator % must be integer. Got : " + e1.getType() + " X " +  e2.getType(), 1);
				break;

			default:
				parser.printError("Unrecognized operator!",1);
				break;
		}
		
		if(e1.getType().equals(new StringType()))
			return new StringExp(e1, e2, op);
			
		return new NumberExp(e1, e2, op);
	}
:}

    
terminal SEMIC,PROCEDURE, FUNCTION, LBRACKET, RBRACKET, LPAR, RPAR ,COLON, LBRACE, RBRACE, INT, FLOAT,LIST,OF,STRUCT, ENUM, STRING, CHAR, BOOL,COMMA;
terminal IF, ELSE, CASE;
terminal WHILE, REPEAT;
terminal AFF, SLOT;
terminal RETURN;
terminal AND, OR, LT, GT, LE, GE, EQ, DIFF;
terminal PLUS, MINUS, MINUS_U, MULT, DIV, MODULO;

terminal String IDENTIFIER, INTEGER, FLOATEXP, STRINGEXP, CHAREXP, TRUEEXP, FALSEEXP;

non terminal axiom,constDecl,funct,procedure,struct,structDecls, structDecl, erreur;
non terminal Instruction decl;
non terminal Type type,tupleType, enumDecl, basicType, basicTupleType;
non terminal LinkedList<String> enumElems;
non terminal String enumElem;
non terminal LinkedList<ArgumentInfo> functDecls;
non terminal ArgumentInfo functDecl;
non terminal Instruction block;
non terminal Instruction instrs, instr;
non terminal Expression expr;
non terminal String boolExpr;
non terminal ListNode listDecl;
non terminal Expression variable,functCall;
non terminal EnumExp enumCases;

precedence left COMMA;
precedence right ELSE;
precedence left AND;
precedence left OR;
precedence left LT, GT, LE, GE, EQ, DIFF;
precedence left PLUS, MINUS;
precedence left MULT, DIV, MODULO;
precedence left MINUS_U;
precedence left SLOT;

start with axiom;

axiom ::= 
		funct
		| funct axiom
		| procedure
		| procedure axiom
		| constDecl axiom
		| constDecl	
		| struct axiom
		| struct
		| erreur axiom
		| erreur
		;
		
		
erreur ::= 
		error SEMIC
		{:
			parser.printError("\";\" is missing \n", 1);
		:}
		| error RBRACE
		{:
			parser.printError("\"}\" is missing \n", 1);
		:}
		| error LPAR
		{:
			parser.printError("\"(\" is missing \n", 1);
		:}
		;		
		
		
basicTupleType ::= 
		basicTupleType:t1 COMMA basicType:t2 {: RESULT = new TupleType(t1, t2); :}
		|basicType:t1 {: RESULT = t1; :}
		;
		
tupleType ::= 
		tupleType:t1 COMMA type:t2 {: RESULT = new TupleType(t1, t2); :}
		|type:t1 {: RESULT = t1; :}
		;

basicType ::=		
		INT {: RESULT = new IntType();  :}
		| FLOAT {: RESULT = new FloatType();  :}
		| CHAR   {: RESULT = new CharType(); :}
		| STRING  {: RESULT = new StringType(); :}
		| BOOL {: RESULT = new BoolType(); :}
		| LIST OF basicType:t {: RESULT = new ListType(t); :}
		| enumDecl:e {: RESULT = e; :};
		
type ::=
		LPAR tupleType:t RPAR {: RESULT = t;  :}
		| IDENTIFIER:t 
		{:
			Type type = typeTable.get(t);
			
			if(type == null)
			{
				parser.printError("Type not found : " + t, 1);
			}			
			
			RESULT = type;
		:}
		|INT {: RESULT = new IntType();  :}
		| FLOAT {: RESULT = new FloatType();  :}
		| CHAR   {: RESULT = new CharType(); :}
		| STRING  {: RESULT = new StringType(); :}
		| BOOL {: RESULT = new BoolType(); :}
		| LIST OF type:t {: RESULT = new ListType(t); :}
		| enumDecl:e {: RESULT = e; :}
		;
		

constDecl ::= 
		IDENTIFIER:id EQ expr:i SEMIC
		{:
			if(constTable.containsKey(id))
			{
				parser.printError("Type/Constant already declared : " + id, 1);
			}
			else
			{
				if(i instanceof ConstantLeaf)
				{				
					Constant c = ((ConstantLeaf)i).getValue();
					constTable.put(id, c);
				}
				else if(i instanceof ListNode)
				{
					ListConstant c = new ListConstant((ListNode)i, (ListType)i.getType());
					constTable.put(id, c);
				}
				else if(i instanceof TupleNode)
				{
					if(!(i.getLeft() instanceof TypeExp))
					{
						TupleConstant c = new TupleConstant((TupleNode)i, (TupleType)i.getType());
						constTable.put(id, c);
					}
					else
					{
						TupleType t = (TupleType)i.getType();
						typeTable.put(id, t);
					}
				}
				else if(i instanceof TypeExp)
				{
					TypeExp exp = (TypeExp)i;
					typeTable.put(id, exp.getType());
				}
				else
				{
					parser.printError("Constant can't be set: " + id, 1);
				}				
			}
		:}
		| IDENTIFIER:id EQ  basicType:t  SEMIC
		{:
			if(typeTable.containsKey(id) || constTable.containsKey(id))
				parser.printError("Type/constant already declared : " + id, 1);
			else
				typeTable.put(id, t);
		:}
		| IDENTIFIER:id EQ LPAR basicTupleType:t RPAR SEMIC
		{:
			if(typeTable.containsKey(id) || constTable.containsKey(id))
				parser.printError("Type/constant already declared : " + id, 1);
			else
				typeTable.put(id, t);
		:}
		;	

enumDecl ::= ENUM LPAR enumElems:e RPAR {: RESULT = new EnumType(e);   :}
		;
		
enumElems ::= enumElems:l COMMA enumElem:e
		{:			
			l.add(e);
			RESULT = l;
		:}
		| enumElem:e
		{: 
			LinkedList<String> l = new LinkedList<String>();
							
			l.add(e);
			RESULT = l;  
		:};

enumElem ::= IDENTIFIER:id
		{:		
			if(constTable.containsKey(id))
				parser.printError("Enum element can't be set because of an already existing constant/enum : " + id, 1);
			else
			{
				enumID++;
				constTable.put(id, new EnumConstant(String.valueOf(enumID), id));
			}
			
			RESULT = id;
		:};

block ::=
		LBRACE
		{:
			callerType = null;
		    SyntaxTree sTree = new SyntaxTree(null, null);
		    
		    sTree.setEnvironmentStack(currentNode.getEnvironmentStack());
	    	sTree.pushEnvironment(new Environment());

		    currentNode = sTree;
		:}  instrs:i RBRACE {: RESULT = i; currentNode.popEnvironment(); :}
		| LBRACE RBRACE {: RESULT = new Instruction(null,null); :}
		;


decl ::=  IDENTIFIER:id COLON type:t SEMIC
		{:
			if(currentNode != null)
			{
				boolean initialized = false;
				
				if(t instanceof ListType || t instanceof StructType)
					initialized = true;
				
				currentNode.getFirstEnvironment().put(id, new VariableInfo(t, initialized));
			}
				
			RESULT = new Assignment(new VariableLeaf(id, t), null);
		:}
		| IDENTIFIER:id COLON type:t AFF expr:e SEMIC
		{:			
			if(currentNode != null)
			{
				currentNode.getFirstEnvironment().put(id, new VariableInfo(t, true));
				
				RESULT = new Assignment(new VariableLeaf(id, t), e); 
			}
			
			if(!t.equals(e.getType()))
				parser.printError("Type mismatch. Expecting : "  + t.toString() + ". Got : "  + e.getType().toString(), 1);
		:} 
		;


structDecls ::= structDecls structDecl | structDecl | erreur;


structDecl ::=  IDENTIFIER:id COLON type:t SEMIC
		{:
			if(currentNode != null)
			{
				currentNode.getFirstEnvironment().put(id, new VariableInfo(t, false));
			}
				
			RESULT = new Assignment(new VariableLeaf(id, t), null);
		:};


struct ::= IDENTIFIER:id EQ STRUCT 
		 {:
		    SyntaxTree sTree = new SyntaxTree(null, null);
		    
		    currentNode = sTree;
		    typeTable.put(id,new StructType(id));
		:}LBRACE structDecls RBRACE 
		{:
			StructType st = (StructType)typeTable.get(id);
			st.setEnvironment(currentNode.getFirstEnvironment());
		:}
		;


boolExpr ::=
		TRUEEXP:t {: RESULT = "true"; :}
		|FALSEEXP:t {:RESULT = "false"; :};


funct ::=
		FUNCTION IDENTIFIER:id LPAR 
		{: 
			currentNode = new SyntaxTree(null, null); 
		:} 
		functDecls:f RPAR COLON type:t
		{:
			functInfo = new FunctionInfo(f, t);
			fctTable.put(id, functInfo);
		:}
		 block:b
		{:
			functInfo.setSyntaxTree(b);
			
			if(!b.containsReturn())
				parser.printError("Function " + id + " must return a value\n", 1);
		:}
		|FUNCTION IDENTIFIER:id LPAR RPAR COLON type:t 
		{: 
			currentNode = new SyntaxTree(null, null); 
			LinkedList<ArgumentInfo> l = new LinkedList<ArgumentInfo>();
			functInfo = new FunctionInfo(l, t);
			fctTable.put(id, functInfo);
		:} 
		block:b
		{:
			functInfo.setSyntaxTree(b);
			
			if(!b.containsReturn())
				parser.printError("Function " + id + " must return a value\n", 1);
		:}
		;
		
		
procedure ::= 
		PROCEDURE IDENTIFIER:id LPAR 
		{:
			currentNode = new SyntaxTree(null, null); 
		:} 
		functDecls:f RPAR 
		{:
			functInfo = new FunctionInfo(f, null);
			fctTable.put(id, functInfo);
		:}
		block:b
		{:
			functInfo.setSyntaxTree(b);
		:}
		|PROCEDURE IDENTIFIER:id LPAR RPAR  
		{: 
			currentNode = new SyntaxTree(null, null); 
			LinkedList<ArgumentInfo> l = new LinkedList<ArgumentInfo>();
			functInfo = new FunctionInfo(l, null);
			fctTable.put(id, functInfo);
		:} 
		block:b
		{:
			functInfo.setSyntaxTree(b);
		:}
		;

		
functDecls ::=
		functDecls:l COMMA functDecl:f
		{:
			l.add(f);
			RESULT = l;
		:}
		| functDecl:f 
		{: 
			LinkedList<ArgumentInfo> l = new LinkedList<ArgumentInfo>();
			l.add(f);
			RESULT = l;  
		:}
		;


functDecl ::=  IDENTIFIER:id COLON type:t 
		{: 
			currentNode.getFirstEnvironment().put(id, new VariableInfo(t, true));  
			RESULT = new ArgumentInfo(id, t); 
		:} 
		;


enumCases ::=
		enumCases:e IDENTIFIER:id  COLON instr:s
		{:
			if(!constTable.containsKey(id))
				parser.printError("Enum not found : " + id, 1);
				
			RESULT = new EnumExp(id,s,e);
		:}
		|IDENTIFIER:id  COLON instr:s
		{:
			if(!constTable.containsKey(id))
				parser.printError("Enum not found : " + id, 1);
				
			RESULT = new EnumExp(id,s,null);
		:}
		;
		
instr ::= 
		IF LPAR expr:e RPAR block:i1 ELSE block:i2  {: RESULT = new Condition(e, new ElseCondition(i1, i2)); :}
		| IF LPAR expr:e RPAR block:i   {: RESULT = new Condition(e, i); :}
		| CASE variable:v LBRACE enumCases:d RBRACE
		{:
			if(v.getType() instanceof EnumType)
			{
				RESULT = new Case(v,d);
			}
			else
			{
				parser.printError("Type mismatch. Expecting type enum for CASE ", 1);
			}
		:}
		| variable:v AFF expr:e SEMIC 
		{: 			
			if(v.getType() != null && e.getType() != null)
			{
				if(v.getType() instanceof EnumType && e instanceof ConstantLeaf)
				{
					EnumType et = (EnumType)v.getType();
					ConstantLeaf cl = (ConstantLeaf)e;
					Constant cons = cl.getValue();
					
					EnumConstant c = null;
					
					if(cons instanceof EnumConstant)
						c = (EnumConstant)cons;
					
					if(c == null || !et.containsEnum(c.getName()))
						parser.printError("Enum mismatch. Expecting : " + v.getType().toString(), 1);
				}
				else if(!v.getType().equals(e.getType()))
				{
					parser.printError("Type mismatch. Expecting : "  + v.getType().toString() + ". Got : "  + e.getType().toString(), 1);
				}					
				else if(v instanceof TypeExp)
				{
					parser.printError("Impossible to define a type", 1);
				}
					
				if(v instanceof VariableLeaf)
				{
					VariableLeaf vl = (VariableLeaf)v;
					VariableInfo vi = currentNode.findInEnvironment(vl.getName());
					
					if(vi != null)
						vi.initialize();
				}
				else if(v instanceof StructAccessor)
				{
					 StructAccessor sa = (StructAccessor)v;
					 sa.initializeVar();
				}
				
				RESULT = new Assignment(v, e); 
			}
		:}
		| WHILE LPAR expr:e RPAR block:b
		{:
		//Distinguer while et repeat
			if(e.getType() instanceof BoolType)
			{
				RESULT = new While(e, b); 
				
			} 
			else
			{
				parser.printError("Loop test expression must be a boolean", 1);
			}
		:}
		| REPEAT block:b WHILE LPAR expr:e RPAR 
		{:
			if(e.getType() instanceof BoolType)
			{
				RESULT = new Repeat(e, b); 
			} 
			
			else
			{
				parser.printError("Loop test expression must be a boolean", 1);
			}
		:}
		| decl:d {: RESULT = d;	:}
		| variable:v SEMIC 
		{: 
			if(v instanceof FunctionCall)
			{
				RESULT = new Instruction(v, null);
			}
			else
			{
				parser.printError(v.toString() + " is not a function", 0); 
			}
			
		:}
		| RETURN expr:e SEMIC 
		{: 
			if(functInfo != null)
			{
				if(functInfo.getOutputType().equals( e.getType()) )
				{
					RESULT = new  ReturnNode(e);
				}	 
				else
				{
					parser.printError("The return must be of type " + functInfo.getOutputType() +". Got : "+ e.getType() , 1);
					
					RESULT = new  ReturnNode(null);
				}
			}
			else
			{
				parser.printError("Error  with a function", 1);
			}
		:}
		| RETURN  SEMIC 
		{:
			if(functInfo != null)
			{
				if(functInfo.getOutputType() == null )
				{
					RESULT = new  ReturnNode(null);
				}	 
				else
				{
					RESULT = new  ReturnNode(null);
					parser.printError("Procedure can't return value", 1);
				}
			}
			else
			{
				parser.printError("Error  with a function", 1);
			}
		 :}
		| erreur 
		{:
			RESULT = new Instruction(null,null);
		:}
		;

instrs ::= 
		instrs:i1 instr:i2   {: RESULT = new Succ(i1, i2); :}
		| instr:i  {: RESULT = i; :}
		;
		
		
listDecl ::=
		 LBRACKET expr:e RBRACKET
		 {:
			 RESULT = new ListNode(e, null);
		 :}
		 ;
		 
expr ::=
		expr:e1 AND  expr:e2 {: RESULT = constructBoolExp(e1, e2, EnumTagExp.AND ); :} 
		|expr:e1 OR   expr:e2 {: RESULT = constructBoolExp(e1, e2, EnumTagExp.OR  ); :} 
		|expr:e1 LT   expr:e2 {: RESULT = constructBoolExp(e1, e2, EnumTagExp.LT  ); :} 
		|expr:e1 GT   expr:e2 {: RESULT = constructBoolExp(e1, e2, EnumTagExp.GT  ); :} 
		|expr:e1 LE   expr:e2 {: RESULT = constructBoolExp(e1, e2, EnumTagExp.LE  ); :} 
		|expr:e1 GE   expr:e2 {: RESULT = constructBoolExp(e1, e2, EnumTagExp.GE  ); :} 
		|expr:e1 EQ   expr:e2 {: RESULT = constructBoolExp(e1, e2, EnumTagExp.EQ  ); :} 
		|expr:e1 DIFF expr:e2 {: RESULT = constructBoolExp(e1, e2, EnumTagExp.DIFF); :} 

		|expr:e1 PLUS   expr:e2 {: RESULT = constructNumberExp(e1, e2, EnumTagExp.PLUS ); :}
		|expr:e1 MINUS  expr:e2 {: RESULT = constructNumberExp(e1, e2, EnumTagExp.MINUS); :}
		|expr:e1 MULT   expr:e2 {: RESULT = constructNumberExp(e1, e2, EnumTagExp.MULT ); :}
		|expr:e1 DIV    expr:e2 {: RESULT = constructNumberExp(e1, e2, EnumTagExp.DIV  ); :}
		|expr:e1 MODULO expr:e2 {: RESULT = constructNumberExp(e1, e2, EnumTagExp.MOD  ); :}
		|MINUS expr:e {: RESULT = constructNumberExp(e, null, EnumTagExp.MINUS_U); :} %prec MINUS_U

		| expr:e1 COMMA expr:e2 
		{: 	
			RESULT = new TupleNode(e1, e2);
		:}
		| listDecl:dl {:
			if(!dl.isListHasAllSameType())
			{
				parser.printError("The list expression needs to contain the same type everywhere", 1);
			}
		
			RESULT = dl;
		:}
		|LPAR expr:e RPAR {: RESULT = e; :}
		|INTEGER:it {: 
			RESULT = new ConstantLeaf(new IntConstant(it)); 
			:}
		|FLOATEXP:d {: 
			RESULT = new ConstantLeaf(new FloatConstant(d)); 
			:}
		|STRINGEXP:st {: 
			RESULT = new ConstantLeaf(new StringConstant(st));  
			:}
		|CHAREXP:c {: 
			RESULT = new ConstantLeaf(new CharConstant(c));  
			:}
		|boolExpr:b {: 
			RESULT = new ConstantLeaf(new BoolConstant(b)); 
			:}
		|variable:v 
		{: 
			if(v instanceof VariableLeaf)
			{
				VariableLeaf vl = (VariableLeaf)v;
				VariableInfo vi = currentNode.findInEnvironment(vl.getName());
				
				if(vi != null && !vi.initialized())
					parser.printError("Variable not set : " + vl.getName(), 0);
			}
			else if(v instanceof StructAccessor)
			{
				StructAccessor sa = (StructAccessor)v;
				if(!sa.isVarInitialized())
					parser.printError("Variable not set : " + sa.toVariableString(), 0);
			}
			
			RESULT = v; 
		:}
		;


functCall ::= 
 		IDENTIFIER:id LPAR RPAR
    	{:
    		FunctionInfo info = fctTable.get(id);
    		if(info != null)
    		{
    			if(!info.getArgs().isEmpty())
    			{
    				parser.printError("Function "+id+" wrong call", 1);
    			}
    			RESULT = new FunctionCall( new FunctionRef(id, info), null);
    		}
			else
			{
				NativeFunctionInfo nfi = nativeFctTable.get(id);
				if(nfi == null)
					parser.printError("Fonction "+id+" not found", 1);
				else
				{
					if(!nativeFctTable.isCallPermitted(id, null, callerType))
					{
						parser.printError("Function "+id+" undefined or wrong call", 1);
					}					
				}

				RESULT = new FunctionCall(new FunctionRef(id, nfi), null);
			}
    	:}
		| IDENTIFIER:id LPAR expr:e RPAR
    	{:
    		FunctionInfo info = fctTable.get(id);
    		if(info != null)
    		{
    			if(!fctTable.isCallPermitted(id, e))
    			{
    				parser.printError("Function "+id+" wrong call", 1);
    			}
    		
    			RESULT = new FunctionCall( new FunctionRef(id, info), e);
    		}
			else
			{
				
				NativeFunctionInfo nfi = nativeFctTable.get(id);
				if(nfi == null)
					parser.printError("Fonction "+id+" not found", 1);
				else
				{
					if(!nativeFctTable.isCallPermitted(id, e, callerType))
					{
						parser.printError("Function "+id+" undefined or wrong call", 1);
					}

					RESULT = new FunctionCall(new FunctionRef(id, nfi), e);
				}
			}
    	:}
    	;
		
	
variable ::=
    	IDENTIFIER:id 
    	{:    		
    		Constant c = constTable.get(id);
    		
    		if(c == null)
    		{
    			VariableInfo vi = null;
    			if(currentNode != null)
    				vi = currentNode.findInEnvironment(id);
    			
				if(vi != null)
				{
					Type t = vi.getType();
					RESULT = new VariableLeaf(id, t);
				}
				else
				{
					Type t = typeTable.get(id);
					
					if(t != null)
					{
						RESULT = new TypeExp(t);
					}
					else
					{
						parser.printError("Variable, constant or type " + id + " not found", 1);
						RESULT = new VariableLeaf(id + " NOT FOUND", new UnknownType());
					}
				}
    		}
    		else
    		{
				Type t = typeTable.getEnumType(id);
				
				if(t == null)
    				RESULT = new ConstantLeaf(c);
    			else
    			{
    				EnumConstant ec = (EnumConstant)c;
    				ec.setType(t);
    				RESULT = new ConstantLeaf(ec);
    			}
    		}
    	:}
    	| variable:v SLOT 
    	{:
    		callerType = v.getType();
    		
    		if(callerType instanceof StructType)
    		{     		
    			StructType st = (StructType)v.getType();    			 
				currentNode.pushEnvironment(st.getEnvironment()); 
			}
		:} 
		variable:v1 
		{:    				
    		if(v.getType() instanceof StructType)
    		{
	    		StructType st = (StructType)v.getType();
				VariableInfo vi = st.getEnvironment().get(((VariableLeaf)v1).getName());
				
				currentNode.popEnvironment();
				
				RESULT = new StructAccessor(v, v1);
    		}
    		
    		if(v1 instanceof FunctionCall)
			{
				RESULT = v1;
			}
    	:}
    	| functCall:fc {: callerType = null; RESULT = fc;:}
    	| variable:v LBRACKET expr:e RBRACKET
    	{:
    		boolean isOk = false;
    		
    		if(v instanceof VariableLeaf || v instanceof ListAccessor || v instanceof StructAccessor)
    		{
    			if(v.getType() instanceof ListType)
    			{
		    		if(e.getType().equals(new IntType()))
	    			{
	    				RESULT = new ListAccessor(v, e);
	    				isOk = true;
	    			}
	    		}
    		}
    			//error dans tous les autres cas
    		if(!isOk)
    		{
    			parser.printError("Accessor to the list impossible, wrong type", 1);
    			RESULT = new ListAccessor(new VariableLeaf("wrong type", new UnknownType()), null);
    		}
    	:}
		;
	
